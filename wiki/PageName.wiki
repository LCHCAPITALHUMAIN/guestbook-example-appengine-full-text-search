= How to maka a gae application searchable using self merge joins =
== Abstract ==
Many complain that Google App Engine is not able to do a full text search. However, using the presentation of Bratt Slatkin at Google IO the implementation is pretty straight forward. The following article will give a practical introduction how to implement full text search on GAE. The code will be GAE/J + JDO only, but the concepts can be easily converted into Python or JPA.

=== Goal ===
 * Develop a searchable guestbook example (much like the one shipped with the SDK) 
 * The full text search should be fuzzy within limits.

=== Some things before we start ===
 * *Self merge joins and list properties*: You can query an entity efficiently based on so called "list properties" via self merge joins. I will not talk about that in detail, but you should watch Brett's excellent talk at Google IO 09 about the topic. It will answer everything: Google I/O 2009 - Building Scalable, Complex Apps on App Engine http://www.youtube.com/watch?v=AgaL6NGpkB8

 * *Full Text Search (FTS)*: Well. FTS is a really huge topic and can be done in a myriad of different ways. Check out wikipedia for a primer: http://en.wikipedia.org/wiki/Full_text_search

 * *The art of stemming*: One of the most basic things to enable some kind of inexact search is so called "stemming". It's the reduction of words towards their basic form. http://en.wikipedia.org/wiki/Stemming


== The project ==
=== Preparations ===
The whole project is availbale at google code: http://code.google.com/p/guestbook-example-appengine-full-text-search

This should make it really simple to browse the source and checkout the project so you can try it yourself. Or check it out.

=== The project - walkthrough indexing ===
 * *guestbook.jsp*: This file is the first file that is loaded. You can enter new entries into the guestbook (GuestBookEntry.java). But you can also search all guestbook entries using the upper form.
 * *GuestBookEntry.java*: A simple JDO file with persistent fields. However, there is one special field: *fts*. It is a Set of Strings. They will be filled with the terms that allow for a full text search. If you inspect the constructor, you will see a call to 
{{{
SearchJanitor.updateFTSStuffForGuestBookEntry(this);
}}}
 * *SearchJanitor.java - method updateFTSStuffForGuestBookEntry*: This method gets a GuestBookEntry and chops it into single words using the SearchJanitorUtils method
{{{
SearchJanitorUtils.getTokensForIndexingOrQuery(...)
}}}
 * *SearchJanitorUtils.getTokensForIndexingOrQuery(...)*: This method uses Lucene and Lucene Snowball to extract words from the given String. But it does more: The Lucene Snowball stemmer reduces the words to the basic form what enables fuzzy search. A search for Kids or Kid will return the same results. kid and Kids will also return the same results.


*Summary indexing*: Ok. So far we have an entity (GuestBookEntry.java) that will be filled with a set of Strings generated from it's content (SearchJanitor.updateFTSStuffForGuestBookEntry(...).
Cool. But the "real" search is missing.

 

=== The project - walkthrough searching ===
 * *search.jsp*: This file gets a parameter "search" and presents results for that search. It does that by consulting
{{{
List<GuestBookEntry> searchResults = SearchJanitor.searchGuestBookEntries(searchString, pm);
}}}
 * *SearchJanitor - method searchGuestBookEntries*: This method does all the "magic". It again chops the search string into single, stemmed words (using the SearchJanitorUtils) and constructs a query that searches for all these Strings in the field "fts" of entity GuestBookEntry. 

*Summary*: We have a search.jsp that uses the same stemming as in the indexing part to translate a string into a searchable set of strings. This set of strings is then in turn queried against the datastore (in the form of slef merge joins on one field). Mission accomplished.




== Limitations of the approach ==
 * 1MB limit on entities
 * Number of terms to search for limited (max around 5 => but precise enough)
 * If you get too many results the search will not work. you have to make sure you are searching in a subset of the data with less than ~200 results.




== Outlook ==
Some thoughts about where to got from here:
 * Add key only queries for more efficient searches
 * Add memcache support for fast queries
 * Add some secret sauce that enables you to "rank" results
 * Precompute date and timestamps to search for them. Don't search for ragens, but search for exact dates like 2009-10 (all entries in August 2009).




== Summary ==
This post showed you how to use self merge joins to index entities of the Google App Engine and make them searchable. The approach has limitations, but it proves that the GAE can be made full text searchable.




== Behind the scenes ==
We are using this approach successfully in our scientific research project scisurfer.com. Ok. We added some secret "ranking" sauce :) But it works quite well for us.

=== SCISURFER.COM ===
The project: Science and scientific communication is changing at an ever increasing speed. It becomes more and more difficult for the individual researcher to follow the latest scientific trends. SCISURFER.COM develops solutions that allow for a comprehensive and up-to-date access to scientific information and trends. Our first application, the SCISURFER.COM reader allows for the scientist to access and surveil more than 10k scientific in one place.

=== People ===
 * Nico GÃ¼ttler, Student
 * Dominic Jansen, M.Sc.
 * Raphael Bauer, PhD